package pkg

import (
	"fmt"
	"os"
	"strings"

	"github.com/charmbracelet/bubbles/spinner"
	"github.com/charmbracelet/lipgloss"
	"github.com/fatih/color"
	"golang.org/x/term"
)

// Color functions for terminal output
var (
	CyanBold   = color.New(color.FgCyan, color.Bold).SprintFunc()
	GreenBold  = color.New(color.FgGreen, color.Bold).SprintFunc()
	YellowBold = color.New(color.FgYellow, color.Bold).SprintFunc()
	BlueBold   = color.New(color.FgBlue, color.Bold).SprintFunc()
	RedBold    = color.New(color.FgRed, color.Bold).SprintFunc()
	White      = color.New(color.FgWhite).SprintFunc()
	Cyan       = color.New(color.FgCyan).SprintFunc()
	Blue       = color.New(color.FgBlue).SprintFunc()
	Green      = color.New(color.FgGreen).SprintFunc()
	Magenta    = color.New(color.FgMagenta).SprintFunc()
)

// UI styling constants
var SpinnerStyle = lipgloss.NewStyle().Foreground(lipgloss.Color("69"))

// UIModel represents the UI state for rendering
type UIModel struct {
	Spinner  spinner.Model
	Fallback bool
	Result   FormattedResponse
}

// CreateSpinner creates and configures a new spinner
func CreateSpinner() spinner.Model {
	s := spinner.New()
	s.Spinner = spinner.Dot
	s.Style = SpinnerStyle
	return s
}

// RenderLoadingView renders the loading state with spinner
func RenderLoadingView(uiModel UIModel) string {
	if uiModel.Fallback {
		return RedBold("\nLost in the tunnel of knowledge. Please try again later.\n")
	}
	return fmt.Sprintf("\n %s %s\n\n", uiModel.Spinner.View(), CyanBold("THINKING.."))
}

// RenderResultView renders the formatted research results
func RenderResultView(result FormattedResponse, modelName string) string {
	b := strings.Builder{}

	// Build the title without a leading newline and with an extra newline after
	title := "âœ¨ === PHOTON RESEARCH RESULTS ==="
	if modelName != "" {
		title += fmt.Sprintf(" (Generated by %s)", modelName)
	}
	title += " âœ¨\n\n"

	// Write the cyan-colored title
	b.WriteString(CyanBold(title))

	// Write summary if present
	if result.Summary != "" {
		b.WriteString("\n" + YellowBold("âœ¨ SUMMARY:") + "\n")
		b.WriteString(wrapToTerminalWidth(White(result.Summary)) + "\n")
	}

	// Write key points if present
	if len(result.KeyPoints) > 0 {
		b.WriteString("\n" + GreenBold("ðŸ’¡ KEY POINTS:") + "\n")
		for i, point := range result.KeyPoints {
			b.WriteString(wrapToTerminalWidth(fmt.Sprintf("%s %d. %s", Cyan("âž¤"), i+1, White(point))) + "\n")
		}
	}

	// Bottom divider
	b.WriteString("\n" + CyanBold("âœ¨ ========================== âœ¨") + "\n")
	return b.String()
}

// wrapToTerminalWidth wraps a string to the current terminal width (default 80 if not a tty)
func wrapToTerminalWidth(s string) string {
	width := 80
	if term.IsTerminal(int(os.Stdout.Fd())) {
		w, _, err := term.GetSize(int(os.Stdout.Fd()))
		if err == nil && w > 20 {
			width = w
		}
	}
	return wrapString(s, width)
}

// wrapString splits a string into lines of max width
func wrapString(s string, width int) string {
	var out strings.Builder
	for _, line := range strings.Split(s, "\n") {
		for len(line) > width {
			idx := width
			// try to break at space
			for i := width; i > 0; i-- {
				if line[i] == ' ' {
					idx = i
					break
				}
			}
			out.WriteString(line[:idx])
			out.WriteString("\n")
			line = strings.TrimSpace(line[idx:])
		}
		out.WriteString(line)
		out.WriteString("\n")
	}
	return out.String()
}

// PrintFormattedResearch prints research results directly to console
func PrintFormattedResearch(research FormattedResponse, modelName string) {
	fmt.Println(RenderResultView(research, modelName))
}
